<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Cube Placement</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        
        button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }
        
        #reticle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        
        #fallback-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <div id="reticle"></div>
        <div id="ui">
            <button id="enter-ar">Enter AR</button>
            <button id="reset">Reset</button>
            <button id="toggle-grid">Toggle Grid</button>
        </div>
        <div id="fallback-info">
            <p>WebAR not supported. Showing fallback 3D preview.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer;
        let arSession = null;
        let reticleVisible = false;
        let cubes = [];
        let grid = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hitTestSource = null;
        let frame = null;
        let referenceSpace = null;
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0x808080, 0x404040, 1);
            scene.add(hemisphereLight);
            
            // Setup fallback cube for non-AR mode
            const fallbackCube = new THREE.Mesh(
                new THREE.BoxGeometry(0.25, 0.25, 0.25),
                new THREE.MeshPhongMaterial({ color: 0x00ff00 })
            );
            fallbackCube.position.set(0, 0, -1);
            scene.add(fallbackCube);
            
            // Setup OrbitControls for fallback mode
            let controls = null;
            if ('OrbitControls' in THREE) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
            }
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize AR session
        async function initAR() {
            try {
                // Check if WebXR is supported
                if (!navigator.xr) {
                    console.log('WebXR not supported');
                    showFallback();
                    return;
                }
                
                // Check if AR session is supported
                const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!isARSupported) {
                    console.log('AR not supported');
                    showFallback();
                    return;
                }
                
                // Request AR session
                arSession = await navigator.xr.requestSession('immersive-ar');
                
                // Set up reference space
                referenceSpace = await arSession.requestReferenceSpace('local');
                
                // Set up hit test source
                hitTestSource = await arSession.requestHitTestSource({ space: referenceSpace });
                
                // Update renderer to use XR
                renderer.xr.enabled = true;
                renderer.xr.setSession(arSession);
                
                // Hide fallback info
                document.getElementById('fallback-info').style.display = 'none';
                
                // Show reticle
                document.getElementById('reticle').style.display = 'block';
                
                // Start animation loop
                renderer.setAnimationLoop(animate);
                
                // Listen for session end
                arSession.addEventListener('end', () => {
                    renderer.setAnimationLoop(null);
                    document.getElementById('reticle').style.display = 'none';
                    initScene(); // Reset to fallback
                });
                
            } catch (error) {
                console.error('Error initializing AR:', error);
                showFallback();
            }
        }
        
        // Show fallback 3D preview
        function showFallback() {
            document.getElementById('fallback-info').style.display = 'block';
            renderer.setAnimationLoop(animate);
        }
        
        // Animation loop
        function animate(time, frame) {
            if (arSession && frame) {
                // Get viewer pose
                const pose = frame.getViewerPose(referenceSpace);
                if (pose) {
                    const view = pose.views[0];
                    const projectionMatrix = view.projectionMatrix;
                    const viewMatrix = view.transform.inverse.matrix;
                    
                    camera.projectionMatrix.fromArray(projectionMatrix);
                    camera.matrixWorldInverse.fromArray(viewMatrix);
                    camera.updateMatrixWorld(true);
                }
                
                // Perform hit test
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        if (pose) {
                            // Update reticle position
                            updateReticlePosition(pose.transform.matrix);
                            reticleVisible = true;
                        } else {
                            reticleVisible = false;
                        }
                    } else {
                        reticleVisible = false;
                    }
                    
                    // Show/hide reticle based on hit test results
                    document.getElementById('reticle').style.display = reticleVisible ? 'block' : 'none';
                }
            } else {
                // Fallback camera animation
                camera.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        // Update reticle position based on hit test
        function updateReticlePosition(matrix) {
            // Create a temporary object to get position from matrix
            const tempObject = new THREE.Object3D();
            tempObject.matrix.fromArray(matrix);
            tempObject.updateMatrixWorld(true);
            
            // Position the reticle in 3D space
            const position = new THREE.Vector3();
            position.setFromMatrixPosition(tempObject.matrixWorld);
            
            // Update reticle element position (for UI)
            const vector = position.clone();
            vector.project(camera);
            
            const reticle = document.getElementById('reticle');
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            reticle.style.left = `${x}px`;
            reticle.style.top = `${y}px`;
        }
        
        // Place a cube at the reticle position
        function placeCube() {
            if (!hitTestSource || !reticleVisible) return;
            
            // Get current hit test results
            const frame = renderer.xr.getFrame();
            if (!frame) return;
            
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length === 0) return;
            
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            if (!pose) return;
            
            // Create cube
            const geometry = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            const material = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            const cube = new THREE.Mesh(geometry, material);
            
            // Set position from hit test pose
            const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
            cube.position.setFromMatrixPosition(matrix);
            
            // Add to scene and cubes array
            scene.add(cube);
            cubes.push(cube);
        }
        
        // Reset all placed cubes
        function resetCubes() {
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
        }
        
        // Toggle grid visibility
        function toggleGrid() {
            if (grid) {
                scene.remove(grid);
                grid = null;
            } else {
                grid = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
                scene.add(grid);
            }
        }
        
        // Initialize the application
        function init() {
            initScene();
            
            // Setup event listeners
            document.getElementById('enter-ar').addEventListener('click', initAR);
            document.getElementById('reset').addEventListener('click', resetCubes);
            document.getElementById('toggle-grid').addEventListener('click', toggleGrid);
            
            // Setup tap/click to place cubes
            renderer.domElement.addEventListener('click', () => {
                if (arSession) {
                    placeCube();
                }
            });
            
            // For mobile touch
            renderer.domElement.addEventListener('touchend', (event) => {
                if (arSession) {
                    event.preventDefault();
                    placeCube();
                }
            });
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
