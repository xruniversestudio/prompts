<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>مرآة هالوين التفاعلية</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #8a2be2;
            font-size: 24px;
        }
        #loading .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(138, 43, 226, 0.3);
            border-radius: 50%;
            border-top-color: #8a2be2;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none;
        }
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* مرآة */
        }
        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4500;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 10px #ff4500, 0 0 20px #ff4500;
            opacity: 0;
            z-index: 10;
            width: 80%;
            line-height: 1.4;
        }
        #logo {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 120px;
            height: 60px;
            background: linear-gradient(45deg, #ff8c00, #ff4500);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            opacity: 0;
            z-index: 10;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.7);
        }
        #stage-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #8a2be2;
            font-size: 1rem;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #8a2be2;
            font-size: 0.9rem;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #camera-error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            color: #ff4500;
            text-align: center;
            padding: 20px;
        }
        #retry-button {
            margin-top: 20px;
            padding: 10px 20px;
            background: #8a2be2;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>جاري تحميل مرآة هالوين التفاعلية...</div>
    </div>
    
    <div id="camera-error">
        <h2>تعذر الوصول إلى الكاميرا</h2>
        <p>يجب السماح بتشغيل الكاميرا لاستخدام هذه التجربة.</p>
        <p>يرجى التحقق من إعدادات الكاميرا والمتصفح ثم المحاولة مرة أخرى.</p>
        <button id="retry-button">إعادة المحاولة</button>
    </div>
    
    <div id="video-container">
        <video id="video" autoplay muted playsinline></video>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="stage-indicator">المرحلة 1: التهيئة...</div>
    
    <div id="instructions">
        حافظ على وجهك في الإطار وحاول الابتسام أو فتح فمك!
    </div>
    
    <div id="message">واجه شبحك - عيد هالوين سعيد!</div>
    
    <div id="logo">متجر الشبح</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main application variables
        let scene, camera, renderer;
        let fogParticles = [];
        let bats = [];
        let sparks = [];
        let stage = 0;
        let stageStartTime = 0;
        let video, videoTexture;
        let audioContext, ambientSound, windSound, pulseSound;
        
        // Initialize the application
        async function init() {
            // Setup camera first
            const cameraSuccess = await setupCamera();
            if (!cameraSuccess) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('camera-error').style.display = 'flex';
                return;
            }
            
            // Setup Three.js scene
            setupThreeJS();
            
            // Setup audio
            setupAudio();
            
            // Start the animation loop
            animate();
            
            // Hide loading screen after a short delay
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                stageStartTime = Date.now();
            }, 2000);
        }
        
        async function setupCamera() {
            try {
                // Get video element
                video = document.getElementById('video');
                
                // Request front camera
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                // Set video source
                video.srcObject = stream;
                
                // Show video container
                document.getElementById('video-container').style.display = 'block';
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                return true;
            } catch (error) {
                console.error('Error accessing camera:', error);
                return false;
            }
        }
        
        function setupThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add ambient lighting
            const ambientLight = new THREE.AmbientLight(0x330033, 0.3);
            scene.add(ambientLight);
            
            // Add purple flickering light
            const purpleLight = new THREE.PointLight(0x8a2be2, 0.8, 20);
            purpleLight.position.set(0, 3, 5);
            scene.add(purpleLight);
            
            // Animate the purple light
            function animateLight() {
                const time = Date.now() * 0.001;
                purpleLight.intensity = 0.5 + Math.sin(time * 3) * 0.3;
                requestAnimationFrame(animateLight);
            }
            animateLight();
            
            // Add orange light
            const orangeLight = new THREE.PointLight(0xff4500, 0.5, 15);
            orangeLight.position.set(3, -2, 4);
            scene.add(orangeLight);
            
            // Create fog particles
            createFogParticles();
            
            // Create face overlay effect
            createFaceOverlay();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function createFogParticles() {
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;     // x
                positions[i+1] = (Math.random() - 0.5) * 20;   // y
                positions[i+2] = (Math.random() - 0.5) * 10;   // z
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x8a2be2,
                size: 0.1,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            fogParticles.push(particleSystem);
        }
        
        function createFaceOverlay() {
            // Create a simple face overlay that will be animated
            const faceGeometry = new THREE.SphereGeometry(1, 32, 32);
            const faceMaterial = new THREE.MeshBasicMaterial({
                color: 0x8a2be2,
                transparent: true,
                opacity: 0.0  // Initially invisible
            });
            
            const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
            scene.add(faceMesh);
            
            // Store reference for later use
            window.faceMesh = faceMesh;
        }
        
        function applyRandomFaceMask() {
            if (!window.faceMesh) return;
            
            // Choose a random mask type
            const maskType = Math.floor(Math.random() * 3);
            
            let maskColor, maskEmissive;
            switch(maskType) {
                case 0: // Witch
                    maskColor = 0x8a2be2;
                    maskEmissive = 0x4b0082;
                    break;
                case 1: // Skeleton
                    maskColor = 0xf5f5f5;
                    maskEmissive = 0x888888;
                    break;
                case 2: // Zombie
                    maskColor = 0x00ff00;
                    maskEmissive = 0x006400;
                    break;
            }
            
            // Animate the mask appearance
            window.faceMesh.material.color.setHex(maskColor);
            window.faceMesh.material.opacity = 0.7;
            
            // Add emissive effect
            window.faceMesh.material.emissive = new THREE.Color(maskEmissive);
            window.faceMesh.material.emissiveIntensity = 0.5;
            
            // Pulse animation
            let pulseDirection = 1;
            const pulseInterval = setInterval(() => {
                window.faceMesh.material.emissiveIntensity += 0.02 * pulseDirection;
                
                if (window.faceMesh.material.emissiveIntensity >= 0.8) {
                    pulseDirection = -1;
                } else if (window.faceMesh.material.emissiveIntensity <= 0.3) {
                    pulseDirection = 1;
                }
                
                // Stop pulsing after stage 3
                if (stage >= 3) {
                    clearInterval(pulseInterval);
                }
            }, 100);
        }
        
        function createBats() {
            // Create bat particles
            for (let i = 0; i < 5; i++) {
                const batGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const batMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const bat = new THREE.Mesh(batGeometry, batMaterial);
                
                // Position bats around the face
                bat.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                
                // Add velocity
                bat.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                scene.add(bat);
                bats.push(bat);
                
                // Remove bats after a while
                setTimeout(() => {
                    scene.remove(bat);
                    bats = bats.filter(b => b !== bat);
                }, 3000);
            }
        }
        
        function createSparks() {
            // Create spark particles
            for (let i = 0; i < 10; i++) {
                const sparkGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                
                // Position sparks around the face
                spark.position.set(
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5
                );
                
                // Add velocity
                spark.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    Math.random() * 0.05,
                    (Math.random() - 0.5) * 0.05
                );
                
                spark.userData.life = 1.0;
                
                scene.add(spark);
                sparks.push(spark);
            }
        }
        
        function setupAudio() {
            try {
                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create ambient whisper sound (simulated with noise)
                const ambientNoise = audioContext.createOscillator();
                const ambientGain = audioContext.createGain();
                ambientNoise.type = 'sawtooth';
                ambientNoise.frequency.value = 60;
                ambientGain.gain.value = 0.05;
                ambientNoise.connect(ambientGain);
                ambientGain.connect(audioContext.destination);
                ambientNoise.start();
                
                // Create wind sound (simulated with filtered noise)
                const windNoise = audioContext.createOscillator();
                const windFilter = audioContext.createBiquadFilter();
                const windGain = audioContext.createGain();
                windNoise.type = 'sawtooth';
                windNoise.frequency.value = 40;
                windFilter.type = 'lowpass';
                windFilter.frequency.value = 200;
                windGain.gain.value = 0.03;
                windNoise.connect(windFilter);
                windFilter.connect(windGain);
                windGain.connect(audioContext.destination);
                windNoise.start();
                
                // Store references for later control
                ambientSound = ambientGain;
                windSound = windGain;
            } catch (error) {
                console.error('Audio setup failed:', error);
            }
        }
        
        function playPulseSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function updateStage() {
            const currentTime = Date.now();
            const elapsed = (currentTime - stageStartTime) / 1000;
            
            // Stage progression
            if (elapsed < 3 && stage !== 1) {
                stage = 1;
                document.getElementById('stage-indicator').textContent = "المرحلة 1: التهيئة...";
            } else if (elapsed >= 3 && elapsed < 7 && stage !== 2) {
                stage = 2;
                document.getElementById('stage-indicator').textContent = "المرحلة 2: تحويل الوجه";
                applyRandomFaceMask();
                playPulseSound();
                
                // Simulate facial expression detection
                startExpressionDetection();
            } else if (elapsed >= 7 && elapsed < 10 && stage !== 3) {
                stage = 3;
                document.getElementById('stage-indicator').textContent = "المرحلة 3: التأثيرات التفاعلية";
            } else if (elapsed >= 10 && elapsed < 15 && stage !== 4) {
                stage = 4;
                document.getElementById('stage-indicator').textContent = "المرحلة 4: الرسالة النهائية";
                showMessage();
            } else if (elapsed >= 15) {
                // Reset for looping
                stageStartTime = currentTime;
                resetEffects();
            }
        }
        
        function startExpressionDetection() {
            // Simulate random facial expressions for demo purposes
            setInterval(() => {
                if (stage === 2 || stage === 3) {
                    const randomAction = Math.random();
                    
                    if (randomAction < 0.3) {
                        createBats();
                    } else if (randomAction < 0.6) {
                        createSparks();
                    }
                }
            }, 2000);
        }
        
        function showMessage() {
            const message = document.getElementById('message');
            const logo = document.getElementById('logo');
            
            // Animate message appearance
            message.style.opacity = 1;
            message.style.transition = 'opacity 1s ease-in-out';
            
            // Animate logo appearance
            setTimeout(() => {
                logo.style.opacity = 1;
                logo.style.transition = 'opacity 1s ease-in-out';
            }, 1000);
            
            // Apply glitch effect
            applyGlitchEffect();
        }
        
        function applyGlitchEffect() {
            // Simplified glitch effect by randomly shifting camera position
            const originalX = camera.position.x;
            const originalY = camera.position.y;
            
            let glitchCount = 0;
            const glitchInterval = setInterval(() => {
                camera.position.x = originalX + (Math.random() - 0.5) * 0.1;
                camera.position.y = originalY + (Math.random() - 0.5) * 0.1;
                
                glitchCount++;
                if (glitchCount > 10) {
                    clearInterval(glitchInterval);
                    camera.position.x = originalX;
                    camera.position.y = originalY;
                }
            }, 100);
        }
        
        function resetEffects() {
            // Reset stage indicator
            document.getElementById('stage-indicator').textContent = "المرحلة 1: التهيئة...";
            
            // Hide message and logo
            document.getElementById('message').style.opacity = 0;
            document.getElementById('logo').style.opacity = 0;
            
            // Reset face overlay
            if (window.faceMesh) {
                window.faceMesh.material.opacity = 0.0;
            }
            
            // Clear particles
            bats.forEach(bat => scene.remove(bat));
            bats = [];
            sparks.forEach(spark => scene.remove(spark));
            sparks = [];
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update stage
            updateStage();
            
            // Update fog particles
            if (fogParticles.length > 0) {
                fogParticles[0].rotation.y += 0.001;
                fogParticles[0].position.y = Math.sin(Date.now() * 0.001) * 0.1;
            }
            
            // Update bats
            bats.forEach(bat => {
                bat.position.add(bat.userData.velocity);
                bat.userData.velocity.y -= 0.001; // gravity
                
                // Random movement
                bat.userData.velocity.x += (Math.random() - 0.5) * 0.01;
                bat.userData.velocity.z += (Math.random() - 0.5) * 0.01;
            });
            
            // Update sparks
            sparks.forEach(spark => {
                spark.position.add(spark.userData.velocity);
                spark.userData.life -= 0.02;
                spark.material.opacity = spark.userData.life;
                
                if (spark.userData.life <= 0) {
                    scene.remove(spark);
                    sparks = sparks.filter(s => s !== spark);
                }
            });
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Retry camera access
        document.getElementById('retry-button').addEventListener('click', function() {
            document.getElementById('camera-error').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            init();
        });
        
        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
