<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>WebXR AR — Three.js Interactive Demo</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #help { position:fixed; left:12px; bottom:12px; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size:13px; line-height:1.4; background:rgba(0,0,0,.55); padding:10px 12px; border-radius:10px; backdrop-filter: blur(6px); }
    #help b{color:#cde6ff}
    #enter { position:fixed; right:12px; bottom:12px; z-index:5 }
    #enter button{ font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-weight:600; font-size:14px; padding:10px 14px; border-radius:10px; border:none; background:#1e90ff; color:#fff; cursor:pointer; }
    #toast{position:fixed; top:12px; left:50%; transform:translateX(-50%); background:rgba(34,34,34,.8); color:#fff; padding:8px 12px; border-radius:12px; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size:13px; display:none}
  </style>
</head>
<body>
  <div id="help">
    <div><b>AR Controls</b></div>
    <div>• Tap to place object on reticle</div>
    <div>• Drag 1 finger = move</div>
    <div>• Pinch = scale • Twist = rotate</div>
    <div>• Double‑tap object = change color</div>
    <div style="opacity:.8;margin-top:6px">No WebXR? It falls back to a standard 3D view.</div>
  </div>
  <div id="enter"></div>
  <div id="toast"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.165.0/examples/jsm/webxr/ARButton.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

    // --- basic scene setup ---
    const scene = new THREE.Scene();
    scene.background = null; // let the camera feed show through in AR

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting (works in AR and fallback)
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(2, 5, 2);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    scene.add(dir);

    // Fallback ground + grid (visible only outside AR)
    const fallbackGroup = new THREE.Group();
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0, roughness:1 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    fallbackGroup.add(ground);

    const grid = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
    grid.position.y = 0.001;
    fallbackGroup.add(grid);

    scene.add(fallbackGroup);

    // A simple shadow-catching plane for AR (invisible, receives shadow)
    const arShadowMat = new THREE.ShadowMaterial({ opacity: 0.35 });
    const arShadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), arShadowMat);
    arShadowPlane.rotation.x = -Math.PI/2;
    arShadowPlane.receiveShadow = true;
    arShadowPlane.visible = false; // only visible in AR
    scene.add(arShadowPlane);

    // Reticle for AR placement
    const reticleGeo = new THREE.RingGeometry(0.06, 0.07, 32).rotateX(-Math.PI/2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0x66ccff });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.visible = false;
    scene.add(reticle);

    // Interactive object factory
    function createInteractive() {
      // A pretty parametric object: rounded box + top cone + emissive ring
      const group = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.18, 0.1, 0.18),
        new THREE.MeshStandardMaterial({ color: 0x29b6f6, metalness: 0.2, roughness: 0.4 })
      );
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      const topper = new THREE.Mesh(
        new THREE.ConeGeometry(0.08, 0.12, 24),
        new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.25 })
      );
      topper.position.y = 0.11;
      topper.castShadow = true;
      group.add(topper);

      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.12, 0.008, 16, 64),
        new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0099ff, emissiveIntensity: 0.6, metalness: 0.2, roughness: 0.2 })
      );
      ring.rotation.x = Math.PI/2;
      ring.position.y = 0.055;
      ring.castShadow = true;
      group.add(ring);

      group.userData.type = 'interactive';
      return group;
    }

    let placed = null; // currently selected/placed object

    // --- WebXR AR session UI ---
    const enter = document.getElementById('enter');
    const arButton = ARButton.createButton(renderer, { requiredFeatures:['hit-test'], optionalFeatures:['dom-overlay'], domOverlay: { root: document.body } });
    enter.appendChild(arButton);

    // Utility: toast
    const toast = (msg, t=1800) => { const el = document.getElementById('toast'); el.textContent = msg; el.style.display = 'block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none', t); };

    // --- Hit test setup ---
    let xrRefSpace = null;
    let xrHitTestSource = null;

    renderer.xr.addEventListener('sessionstart', async () => {
      fallbackGroup.visible = false;
      arShadowPlane.visible = true;
      toast('Move your device to find a surface');

      const session = renderer.xr.getSession();
      xrRefSpace = await session.requestReferenceSpace('local');
      const viewerSpace = await session.requestReferenceSpace('viewer');
      const source = await session.requestHitTestSource({ space: viewerSpace });
      xrHitTestSource = source;
    });

    renderer.xr.addEventListener('sessionend', () => {
      xrHitTestSource = null;
      xrRefSpace = null;
      reticle.visible = false;
      fallbackGroup.visible = true;
      arShadowPlane.visible = false;
    });

    // --- Interaction state ---
    const state = {
      touching:false,
      lastTouch:null,
      selected:null,
      twoFinger:false,
      initial:{ distance:0, angle:0, scale:1, rotation:0, objectRotationY:0 }
    };

    // Raycaster (for tapping objects in AR fallback)
    const raycaster = new THREE.Raycaster();
    const tapVec2 = new THREE.Vector2();

    function screenToWorldOnPlane(x, y, planeY) {
      // Project screen point to world on y=planeY plane
      tapVec2.set((x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(tapVec2, camera);
      const t = (planeY - raycaster.ray.origin.y) / raycaster.ray.direction.y;
      return raycaster.ray.at(t, new THREE.Vector3());
    }

    function onSingleTap(ev){
      if (!renderer.xr.isPresenting()) {
        // Fallback: place/move on ground
        const p = screenToWorldOnPlane(ev.clientX, ev.clientY, 0);
        if (!placed) {
          placed = createInteractive();
          scene.add(placed);
        }
        placed.position.copy(p);
        placed.position.y = 0.05;
        return;
      }
      if (reticle.visible) {
        if (!placed) { placed = createInteractive(); scene.add(placed); }
        placed.position.setFromMatrixPosition(reticle.matrix);
      }
    }

    function onDoubleTap(ev){
      if (!placed) return;
      // cycle a few colors on the body
      const mat = placed.children[0].material; // body
      const palette = [0x29b6f6, 0xff6f61, 0x66bb6a, 0xffc107, 0xab47bc];
      const idx = palette.indexOf(mat.color.getHex());
      mat.color.setHex(palette[(idx+1)%palette.length]);
    }

    // Touch gestures (move / scale / rotate)
    function onTouchStart(ev){
      if (!placed) return;
      if (ev.touches.length === 1){
        state.touching = true; state.twoFinger=false; state.lastTouch = { x:ev.touches[0].clientX, y:ev.touches[0].clientY };
      } else if (ev.touches.length === 2){
        state.twoFinger = true;
        const [a,b] = ev.touches; 
        state.initial.distance = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
        state.initial.angle = Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX);
        state.initial.scale = placed.scale.x;
        state.initial.objectRotationY = placed.rotation.y;
      }
    }
    function onTouchMove(ev){
      if (!placed) return;
      if (state.twoFinger && ev.touches.length === 2){
        const [a,b] = ev.touches;
        const dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
        const angle = Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX);
        const scale = THREE.MathUtils.clamp(state.initial.scale * (dist / state.initial.distance), 0.2, 4);
        placed.scale.setScalar(scale);
        const deltaAngle = angle - state.initial.angle;
        placed.rotation.y = state.initial.objectRotationY + deltaAngle;
      } else if (state.touching && ev.touches.length === 1){
        const t = ev.touches[0];
        // Move on plane at placed's current Y
        const p = screenToWorldOnPlane(t.clientX, t.clientY, placed.position.y - 0.05);
        if (renderer.xr.isPresenting()) {
          // When in AR, keep y from reticle (approx plane)
          placed.position.x = p.x;
          placed.position.z = p.z;
        } else {
          placed.position.x = p.x; placed.position.z = p.z; placed.position.y = 0.05;
        }
      }
    }
    function onTouchEnd(){ state.touching=false; state.twoFinger=false; }

    // Pointer events
    let lastTapTime = 0;
    window.addEventListener('pointerdown', (ev)=>{
      const now = performance.now();
      if (now - lastTapTime < 280) { onDoubleTap(ev); }
      else { onSingleTap(ev); }
      lastTapTime = now;
    });

    window.addEventListener('touchstart', onTouchStart, { passive:true });
    window.addEventListener('touchmove', onTouchMove, { passive:true });
    window.addEventListener('touchend', onTouchEnd, { passive:true });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Animation loop ---
    renderer.setAnimationLoop((timestamp, frame)=>{
      // XR hit test
      if (frame && xrHitTestSource && xrRefSpace){
        const hitTestResults = frame.getHitTestResults(xrHitTestSource);
        if (hitTestResults.length){
          const pose = hitTestResults[0].getPose(xrRefSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
          reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
          arShadowPlane.position.set(reticle.position.x, reticle.position.y - 0.001, reticle.position.z);
        } else {
          reticle.visible = false;
        }
      }

      // Gentle idle animation for visual interest
      if (placed){
        const t = timestamp * 0.001;
        const ring = placed.children[2];
        ring.position.y = 0.055 + Math.sin(t*2)*0.01;
      }

      renderer.render(scene, camera);
    });

    // Camera start position for fallback view
    camera.position.set(1.2, 0.8, 1.2);
    camera.lookAt(0,0,0);

    // Keyboard shortcuts (fallback): WASD to move object, QE to rotate
    window.addEventListener('keydown', (e)=>{
      if (!placed) return;
      const s = (e.shiftKey?0.2:0.05);
      if (e.key==='w') placed.position.z -= s;
      if (e.key==='s') placed.position.z += s;
      if (e.key==='a') placed.position.x -= s;
      if (e.key==='d') placed.position.x += s;
      if (e.key==='q') placed.rotation.y += 0.1;
      if (e.key==='e') placed.rotation.y -= 0.1;
    });
  </script>
</body>
</html>
